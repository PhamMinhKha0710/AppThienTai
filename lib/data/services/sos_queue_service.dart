import 'dart:async';

import 'package:get/get.dart';
import 'package:cuutrobaolu/domain/usecases/create_help_request_usecase.dart';
import 'package:cuutrobaolu/core/constants/enums.dart';
import 'package:cuutrobaolu/presentation/utils/help_request_mapper.dart';
import 'package:cuutrobaolu/presentation/features/home/models/help_request_modal.dart';
import 'package:cuutrobaolu/service/CloudinaryService.dart';
import 'package:cuutrobaolu/core/utils/network_manager.dart';
import 'package:cuutrobaolu/data/services/offline_service.dart';

class SosQueueService extends GetxService {
  final OfflineService _offlineService = OfflineService.to;
  final _processing = false.obs;
  Timer? _timer;

  CreateHelpRequestUseCase get _createUseCase =>
      Get.find<CreateHelpRequestUseCase>();

  Future<void> enqueue(Map<String, dynamic> sos) async {
    final entry = Map<String, dynamic>.from(sos);
    entry['attempts'] = 0;
    entry['createdAt'] = DateTime.now().toIso8601String();
    
    // Save to Hive via OfflineService
    await _offlineService.cacheSosRequest(entry);

    // Try processing immediately if online
    if (await NetworkManager.instance.isConnected()) {
      processQueue();
    }
  }

  Future<void> processQueue() async {
    if (_processing.value) return;
    _processing.value = true;
    try {
      if (!await NetworkManager.instance.isConnected()) return;
      
      final queueMap = _offlineService.getPendingSosRequestsWithKey();
      if (queueMap.isEmpty) return;
      
      // Iterate keys to handle processing
      for (var entry in queueMap.entries) {
        final key = entry.key;
        final item = entry.value;

        try {
          // upload image if present and is local path
          if (item['imagePath'] != null &&
              (item['imageUrl'] == null || item['imageUrl'].toString().isEmpty)) {
            try {
              final uploaded = await CloudinaryService.uploadImageInAsset(
                item['imagePath'],
              );
              if (uploaded != null) {
                item['imageUrl'] = uploaded;
              }
            } catch (e) {
               // Image upload failed, but maybe we can still send text?
               // For now, if image fails, we might still want to proceed or retry?
               // Let's assume critical failure if image upload fails? 
               // No, better to send text SOS than nothing.
               print("Image upload failed: $e");
            }
          }

          // build HelpRequest model
          final model = HelpRequest(
            id: "", // ID auto generated by Firebase
            title: item['title'] ?? "SOS Khẩn cấp",
            description: item['description'] ?? '',
            lat: (item['lat'] as num).toDouble(),
            lng: (item['lng'] as num).toDouble(),
            contact: item['contact'] ?? '',
            address: item['address'] ?? '',
            imageUrl: item['imageUrl'], // Might be null or original path if upload failed
            userId: item['userId'] ?? '',
            severity: RequestSeverity.values.firstWhere(
                (e) => e.toString() == item['severity'].toString(), orElse: () => RequestSeverity.urgent),
            type: RequestType.values.firstWhere(
                (e) => e.toString() == item['type'].toString(), orElse: () => RequestType.rescue),
            status: RequestStatus.pending,
          );

          final entity = HelpRequestMapper.toEntity(model);
          await _createUseCase(entity);
          
          // on success remove from queue using Hive Key
          await _offlineService.removeSosRequest(key.toString());
          
        } catch (e) {
          print("Error processing SOS $key: $e");
          
          // Increment attempts
          int attempts = (item['attempts'] as int?) ?? 0;
          attempts++;
          item['attempts'] = attempts;
          
          if (attempts >= 5) {
             print("SOS $key failed too many times ($attempts). removing from queue.");
             // Option 1: Delete to unblock queue
             await _offlineService.removeSosRequest(key.toString());
             // Option 2: Move to a "failed" box (not implemented yet, so just deleting/ignoring)
          } else {
             // Update the item in Hive so attempts are persisted
             await _offlineService.updateSosRequest(key.toString(), item);
          }
        }
      }
    } finally {
      _processing.value = false;
    }
  }
  
  // Backward compatibility for UI if needed, but UI should check OfflineService
  Future<List<Map<String, dynamic>>> getQueue() async {
    return _offlineService.getPendingSosRequests();
  }

  @override
  void onInit() {
    super.onInit();
    
    // Listen to OfflineService online status to trigger sync immediately
    ever(_offlineService.isOnline, (online) {
      if (online) {
        print("Network restored. Processing SOS queue...");
        processQueue();
      }
    });

    // fallback periodic check
    _timer = Timer.periodic(const Duration(seconds: 20), (_) async {
      if (await NetworkManager.instance.isConnected()) {
        await processQueue();
      }
    });
  }

  @override
  void onClose() {
    _timer?.cancel();
    super.onClose();
  }
}
